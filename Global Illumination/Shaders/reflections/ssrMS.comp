#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba8) uniform readonly image2D inColor;
layout (binding = 1, rgba32f) uniform readonly image2DMS inViewPos;
layout (binding = 2, rgba32f) uniform readonly image2DMS inNormal;
layout (binding = 3, rgba8) uniform image2D resultImage;

layout(binding = 4, std140) uniform readonly UniformBufferObject
{
    mat4 projection;
} ubo;

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC 
    return (2.0 * 0.1 * 50.0) / (0.1 + 50.0 - z * (0.1 - 50.0));
}

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
	return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}

void main()
{
    vec4 color = imageLoad(inColor, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)).rgba;
    vec3 viewPos = imageLoad(inViewPos, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), 0).rgb;
    vec3 normal = imageLoad(inNormal, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), 0).rgb;

     ivec2 inputSize = imageSize(inViewPos);
    vec3 dir = normalize(reflect(viewPos, normal));

    vec3 F0 = vec3(0.04);
    vec3 V = normalize(-viewPos);
    vec3 L = normalize(dir);
    vec3 H = normalize(V + L);
    vec3 kS = fresnelSchlickRoughness(max(dot(H, V), 0.0), F0, color.w);

    vec3 outColor = color.rgb;
    if(length(kS) > 0.0)
    {
        float maxDepth = viewPos.z;
        vec2 lastOffset = gl_GlobalInvocationID.xy;
        float lastDepth = viewPos.z;

        float nPixelSmooth = 50.0;

        float step = 0.2;
        for(int i = 1; i < 64; i++)
        {
            vec3 newViewPos = viewPos + dir * (step * i);

            vec4 offset = vec4(newViewPos, 1.0);
            offset      = ubo.projection * offset;    // from view to clip-space
            offset.xyz /= offset.w;               // perspective divide
            offset.xyz  = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0  

            if(offset.x > 1.0 || offset.y > 1.0 || offset.x < 0.0 || offset.y < 0.0)
                break;

            offset.xy *= inputSize; // to range 0 - textureSize

            float depth = LinearizeDepth(imageLoad(inViewPos, ivec2(offset.xy), 0).z);

            if(depth <= LinearizeDepth(newViewPos.z))
            {
                if(dot(normalize(imageLoad(inViewPos, ivec2(offset.xy), 0).rgb - viewPos), dir) < 0.8)
                    break;

                vec2 fOffset = mix(lastOffset, offset.xy, 0.5);

                //float pixelLeft = float(min(min(inputSize.x - fOffset.x, inputSize.y - fOffset.y), min(fOffset.x, fOffset.y)));
                //float coeffReflection = clamp(mix(0.0, kS, pixelLeft / nPixelSmooth), 0.0, kS);

                outColor = outColor * (vec3(1.0) - kS) + imageLoad(inColor, ivec2(fOffset)).rgb * kS;
                break;
            }

            lastDepth = newViewPos.z;
            lastOffset = offset.xy;
        }

        /*vec3 rayOrigin = vec3(viewPos.x, viewPos.y, viewPos.z) * LinearizeDepth(viewPos.z);

        ivec2 inputSize = imageSize(inViewPos);
        vec3 dir = normalize(reflect(normalize(rayOrigin), normal));

        vec2 hitPixel = vec2(0.0f, 0.0f);
        vec3 hitPoint = vec3(0.0f, 0.0f, 0.0f);

        bool intersection = traceScreenSpaceRay(rayOrigin, dir, 0.0, inputSize, hitPixel, hitPoint);

        float depth = LinearizeDepth(imageLoad(inViewPos, ivec2(hitPixel.xy)).z);
        if(hitPixel.x > inputSize.x || hitPixel.x < 0.0f || hitPixel.y > inputSize.y || hitPixel.y < 0.0f)
        {
            intersection = false;
        }

        if(intersection)
            outColor =  outColor * (1.0 - 0.5) + imageLoad(inColor, ivec2(hitPixel)).rgb * 0.5;*/
    }

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(outColor, 1.0));
}
