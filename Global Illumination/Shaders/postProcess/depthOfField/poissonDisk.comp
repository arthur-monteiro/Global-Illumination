#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba32f) uniform readonly image2D inColor;
layout (binding = 1, rgba16f) uniform readonly image2D inDepthAndBlur;
layout (binding = 2, rgba32f) uniform image2D outColor;

vec2 poissonDisk[64] = vec2[]( 
	vec2( 0.063326, 0.142369 ),
	vec2( 0.155736, 0.065157 ),
	vec2( 0.170019, -0.040254 ),
	vec2( 0.203528, 0.214331 ),
	vec2( 0.222999, -0.215125 ),
	vec2( -0.098422, -0.295755 ),
	vec2( 0.099094, -0.308023 ),
	vec2( 0.034028, 0.325968 ),
	vec2( 0.039766, -0.3961 ),
	vec2( 0.175817, 0.382366 ),
	vec2( 0.421003, 0.02707 ),
	vec2( -0.44084, 0.137486 ),
	vec2( 0.487472, -0.063082 ),
	vec2( 0.464034, -0.188818 ),
	vec2( 0.470016, 0.217933 ),
	vec2( 0.200476, 0.49443 ),
	vec2( -0.075838, -0.529344 ),
	vec2( 0.385784, -0.393902 ),
	vec2( 0.503098, -0.308878 ),
	vec2( 0.062655, -0.611866 ),
	vec2( -0.467574, -0.405438 ),
	vec2( -0.178564, -0.596057 ),
	vec2( -0.149693, 0.605762 ),
	vec2( 0.50444, 0.372295 ),
	vec2( 0.364483, 0.511704 ),
	vec2( 0.634388, -0.049471 ),
	vec2( 0.643361, 0.164098 ),
	vec2( 0.315226, -0.604297 ),
	vec2( -0.688894, 0.007843 ),
	vec2( -0.620106, -0.328104 ),
	vec2( 0.678884, -0.204688 ),
	vec2( 0.078707, -0.715323 ),
	vec2( -0.667531, 0.32609 ),
	vec2( -0.545396, 0.538133 ),
	vec2( -0.772454, -0.090976 ),
	vec2( 0.001801, 0.780328 ),
	vec2( 0.69396, -0.366253 ),
	vec2( 0.64568, 0.49321 ),
	vec2( 0.566637, 0.605213 ),
	vec2( -0.299417, 0.791925 ),
	vec2( -0.248268, -0.814753 ),
	vec2( -0.817194, -0.271096 ),
	vec2( -0.494552, -0.711051 ),
	vec2( -0.613392, 0.617481 ),
	vec2( -0.146886, -0.859249 ),
	vec2( -0.016205, -0.872921 ),
	vec2( 0.751946, 0.453352 ),
	vec2( -0.69689, -0.549791 ),
	vec2( 0.789239, -0.419965 ),
	vec2( -0.084078, 0.898312 ),
	vec2( 0.145177, -0.898984 ),
	vec2( -0.885922, 0.215369 ),
	vec2( -0.780145, 0.486251 ),
	vec2( 0.488876, -0.783441 ),
	vec2( 0.724479, -0.580798 ),
	vec2( 0.612476, 0.705252 ),
	vec2( 0.391522, 0.849605 ),
	vec2( 0.354411, -0.88757 ),
	vec2( -0.371868, 0.882138 ),
	vec2( -0.578845, -0.768792 ),
	vec2( -0.651784, 0.717887 ),
	vec2( -0.705374, -0.668203 ),
	vec2( 0.034211, 0.97998 ),
	vec2( 0.97705, -0.108615 )
);

void main()
{
    float maxSample = 32.0;
    float centerBlur = imageLoad(inDepthAndBlur, ivec2(gl_GlobalInvocationID.xy)).g;
    float centerDepth = imageLoad(inDepthAndBlur, ivec2(gl_GlobalInvocationID.xy)).r;

    vec3 colorSum = imageLoad(inColor, ivec2(gl_GlobalInvocationID.xy)).rgb;
    float totalContribution = 1.0;
    if(centerBlur > 0.0)
    {
        float cocSize = centerBlur * 10.0;

        int numSample = int(maxSample * centerBlur);
        for(int i = 0; i < 64; i += 64 / int(maxSample))
        {
            ivec2 coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(poissonDisk[i] * cocSize);
            vec3 tapColor = imageLoad(inColor, coords).rgb;
            vec2 depthBlur = imageLoad(inDepthAndBlur, coords).rg;

			// Compute tap contribution based on depth and blurriness
			float tapContribution = (depthBlur.x > centerDepth) ? 1.0 : depthBlur.y;

			// Accumulate color and sample contribution
			colorSum += tapColor * tapContribution;
			totalContribution += tapContribution;
        }
    }

    imageStore(outColor, ivec2(gl_GlobalInvocationID.xy), vec4(colorSum / totalContribution, imageLoad(inColor,  ivec2(gl_GlobalInvocationID.xy)).a));

    /*float chromaticAberrationSize = clamp(blurAmount * 2.0 - 1.0, 0.0, 1.0);
    ivec2 chromaticAberrationOffsetR = ivec2(vec2(-2.0, 0.0) * chromaticAberrationSize);
    ivec2 chromaticAberrationOffsetG = ivec2(vec2(0.0, -1.0) * chromaticAberrationSize);
    ivec2 chromaticAberrationOffsetB = ivec2(vec2(2.0, 0.0) * chromaticAberrationSize);

    int numSample = int(64.0 * blurAmount);
    float discRadius = abs(blurAmount * 5.0);
    ivec2 textureSize = imageSize(inColor);

    vec3 cOut = imageLoad(inColor, ivec2(gl_GlobalInvocationID.xy)).rgb;
    float divisor = 1.0;
    for(int i = 0; i < numSample; ++i)
    {
        ivec2 coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(poissonDisk[i] * discRadius);

        float colorR = imageLoad(inColor, coords + chromaticAberrationOffsetR).r;
        float colorG = imageLoad(inColor, coords + chromaticAberrationOffsetG).g;
        float colorB = imageLoad(inColor, coords + chromaticAberrationOffsetB).b;    

        float offsetDepth =  imageLoad(inDepthAndBlur,coords).r;
        float depthCheck = clamp(mix(1.0, 0.0, abs(centerDepth - offsetDepth) / 4.0), 0.0, 1.0);

        cOut += vec3(colorR, colorG, colorB) * depthCheck;
        divisor += depthCheck;
    }

    cOut /= divisor;

    vec3 result = cOut + imageLoad(inBokehPoints, ivec2(gl_GlobalInvocationID.xy)).rgb;

    imageStore(outColor, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));*/
}